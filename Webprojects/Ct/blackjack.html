<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Blackjack Casino</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            overflow: hidden;
            background: #000;
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0a00 0%, #3d1a00 50%, #1a0a00 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .casino-logo {
            font-size: 72px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8),
                         0 0 40px rgba(255, 215, 0, 0.5);
            margin-bottom: 30px;
            font-weight: bold;
            letter-spacing: 5px;
        }

        .loading-text {
            color: #fff;
            font-size: 24px;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .loading-bar-container {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e, #ffd700);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Game UI */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Chip Display */
        #chipDisplay {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid #ffd700;
            color: #fff;
            pointer-events: auto;
        }

        .chip-amount {
            font-size: 32px;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .chip-label {
            font-size: 16px;
            color: #ccc;
        }

        /* Hand Values */
        .hand-value {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid #ffd700;
        }

        #playerValue {
            bottom: 180px;
            left: 30%;
            transform: translateX(-50%);
        }

        #playerValue2 {
            bottom: 180px;
            left: 70%;
            transform: translateX(-50%);
        }

        /* Betting UI */
        #bettingUI {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .chip-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .chip-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7);
        }

        .chip-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        .chip-5 {
            background: radial-gradient(circle, #ff4444, #cc0000);
            border-color: #fff;
        }

        .chip-25 {
            background: radial-gradient(circle, #44ff44, #00cc00);
            border-color: #fff;
        }

        .chip-100 {
            background: radial-gradient(circle, #4444ff, #0000cc);
            border-color: #fff;
        }

        .chip-500 {
            background: radial-gradient(circle, #ff44ff, #cc00cc);
            border-color: #fff;
        }

        .chip-allin {
            background: radial-gradient(circle, #ff0000, #aa0000);
            border-color: #fff;
            font-weight: bold;
            font-size: 18px;
        }

        /* Action Buttons */
        #actionButtons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .action-button {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .action-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-deal {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
        }

        .btn-hit {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-stand {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-double {
            background: linear-gradient(135deg, #f39c12, #d68910);
            color: white;
        }

        .btn-split {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        /* Current Bet Display */
        #currentBet {
            position: absolute;
            bottom: 30px;
            right: 200px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            color: #fff;
            font-size: 16px;
        }

        .bet-amount {
            color: #ffd700;
            font-weight: bold;
            font-size: 24px;
        }

        /* Message Display */
        #messageDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 60px;
            border-radius: 20px;
            border: 3px solid #ffd700;
            color: #fff;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            display: none;
            pointer-events: none;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        #messageDisplay.show {
            display: block;
            animation: messagePopup 0.3s ease-out;
        }

        @keyframes messagePopup {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .win-message {
            color: #2ecc71;
        }

        .lose-message {
            color: #e74c3c;
        }

        .push-message {
            color: #f39c12;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="casino-logo">♠ BLACKJACK ♥</div>
        <div class="loading-text">Loading Casino...</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Game UI -->
    <div id="gameUI">
        <!-- Chip Display -->
        <div id="chipDisplay">
            <div class="chip-amount">$<span id="chipAmount">1000</span></div>
            <div class="chip-label">YOUR CHIPS</div>
        </div>

        <!-- Name Input -->
        <div id="nameInput" style="position: absolute; top: 30px; right: 30px; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 10px; border: 2px solid #ffd700; color: #fff; pointer-events: auto;">
            <label for="playerName">Name:</label>
            <input id="playerName" placeholder="Enter your name" value="Player" style="margin-left: 10px; padding: 5px; border: none; border-radius: 5px; pointer-events: auto;">
            <button onclick="toggleLeaderboard()" style="margin-left: 10px; padding: 5px 10px; border: none; border-radius: 5px; background: #ffd700; color: #000; cursor: pointer;">Leaderboard</button>
        </div>

        <!-- Leaderboard UI -->
        <div id="leaderboardUI" style="display: none; position: absolute; top: 100px; right: 30px; background: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 10px; border: 2px solid #ffd700; color: #fff; max-width: 300px; z-index: 1001; pointer-events: auto;">
            <h2 style="margin: 0 0 10px 0; color: #ffd700;">Leaderboard</h2>
            <ol id="leaderboardList" style="padding-left: 20px;"></ol>
            <input id="gameOverName" placeholder="Enter your name for leaderboard" style="display: none; margin-top: 10px; padding: 5px; width: 100%; box-sizing: border-box; pointer-events: auto;">
            <button id="restartBtn" onclick="submitScore()" style="margin-top: 10px; padding: 10px 20px; background: #ffd700; color: #000; border: none; border-radius: 5px; cursor: pointer; display: none;">Submit Score and Play Again</button>
        </div>

        <!-- Hand Values -->
        <div id="playerValue" class="hand-value" style="display: none;">
            Player: <span id="playerValueText">0</span>
        </div>
        <div id="playerValue2" class="hand-value" style="display: none;">
            Player 2: <span id="playerValueText2">0</span>
        </div>
        <div id="dealerValue" class="hand-value" style="display: none;">
            Dealer: <span id="dealerValueText">0</span>
        </div>

        <!-- Current Bet -->
        <div id="currentBet" style="display: none;">
            Current Bet: $<span class="bet-amount" id="betAmount">0</span>
        </div>

        <!-- Betting Chips -->
        <div id="bettingUI">
            <div class="chip-button chip-5" onclick="placeBet(5)">$5</div>
            <div class="chip-button chip-25" onclick="placeBet(25)">$25</div>
            <div class="chip-button chip-100" onclick="placeBet(100)">$100</div>
            <div class="chip-button chip-500" onclick="placeBet(500)">$500</div>
            <div class="chip-button chip-allin" onclick="placeBet(playerChips)">ALL IN</div>
        </div>

        <!-- Action Buttons -->
        <div id="actionButtons">
            <button class="action-button btn-deal" id="dealBtn" onclick="dealCards()">Deal</button>
            <button class="action-button btn-hit" id="hitBtn" onclick="hit()" style="display: none;">Hit</button>
            <button class="action-button btn-stand" id="standBtn" onclick="stand()" style="display: none;">Stand</button>
            <button class="action-button btn-double" id="doubleBtn" onclick="doubleDown()" style="display: none;">Double Down</button>
            <button class="action-button btn-split" id="splitBtn" onclick="split()" style="display: none;">Split</button>
        </div>

        <!-- Message Display -->
        <div id="messageDisplay"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Variables
        let scene, camera, renderer;
        let table, cards = [];
        let deck = [];
        let playerHand = [];
        let dealerHand = [];
        let playerChips = 1000;
        let currentBet = 0;
        let gameState = 'betting'; // betting, playing, dealer, ended
        let dealerHiddenCard = null;
        let canDouble = false;
        let betChips = [];
        let chipGeometry;
        let playerName = 'Player';
        let maxChips = 1000;
        let leaderboard = [];
        let secondHand = null;
        let currentHand = 'first';

        // Card positions
        const playerCardStart = { x: -2, y: 0.91, z: 2 };
        const dealerCardStart = { x: -2, y: 0.91, z: -2 };
        const cardSpacing = 0.8;

        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0a00);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const spotLight1 = new THREE.SpotLight(0xffffff, 0.8);
            spotLight1.position.set(0, 10, 0);
            spotLight1.castShadow = true;
            spotLight1.angle = Math.PI / 4;
            spotLight1.penumbra = 0.3;
            spotLight1.shadow.mapSize.width = 2048;
            spotLight1.shadow.mapSize.height = 2048;
            scene.add(spotLight1);

            const spotLight2 = new THREE.SpotLight(0xffddaa, 0.3);
            spotLight2.position.set(5, 8, 5);
            scene.add(spotLight2);

            const spotLight3 = new THREE.SpotLight(0xffddaa, 0.3);
            spotLight3.position.set(-5, 8, -5);
            scene.add(spotLight3);

            // Create table
            createTable();

            // Create decorative elements
            createCasinoEnvironment();

            // Initialize deck
            initializeDeck();

            // Start animation
            animate();

            // Simulate loading
            simulateLoading();
            loadLeaderboard();
            document.getElementById('playerName').addEventListener('input', (e) => playerName = e.target.value);
            playerName = document.getElementById('playerName').value;
        }

        function createTable() {
            // Table top (green felt)
            const tableGeometry = new THREE.CylinderGeometry(5, 5, 0.3, 32);
            const tableMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d5c0d,
                roughness: 0.8,
                metalness: 0.1
            });
            table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.y = 0.75;
            table.receiveShadow = true;
            scene.add(table);

            // Table edge (wood)
            const edgeGeometry = new THREE.CylinderGeometry(5.2, 5.2, 0.5, 32);
            const edgeMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a2511,
                roughness: 0.6,
                metalness: 0.2
            });
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            edge.position.y = 0.5;
            scene.add(edge);

            // Table base
            const baseGeometry = new THREE.CylinderGeometry(1, 1.5, 3, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d1810,
                roughness: 0.7
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -1.5;
            scene.add(base);

            // Betting circle
            const circleGeometry = new THREE.RingGeometry(0.8, 1, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.rotation.x = -Math.PI / 2;
            circle.position.set(0, 0.91, 2);
            scene.add(circle);

            // Dealer text
            createText('DEALER', 0, 0.92, -3);

            // Chip geometry for betting
            chipGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16);
        }

        function createText(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
           
            context.fillStyle = '#ffd700';
            context.font = 'bold 60px Georgia';
            context.textAlign = 'center';
            context.fillText(text, 256, 80);
           
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8
            });
            const geometry = new THREE.PlaneGeometry(2, 0.5);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(x, y, z);
            scene.add(mesh);
        }

        function createCasinoEnvironment() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a0505,
                roughness: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -3;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls with warm lighting
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a1810,
                roughness: 0.8
            });

            const wallGeometry = new THREE.PlaneGeometry(50, 20);
           
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 7, -25);
            scene.add(backWall);

            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-25, 7, 0);
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(25, 7, 0);
            scene.add(rightWall);
        }

        function initializeDeck() {
            const suits = ['♠', '♥', '♦', '♣'];
            const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
           
            deck = [];
            for (let suit of suits) {
                for (let value of values) {
                    deck.push({ suit, value });
                }
            }
            shuffleDeck();
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function createCard(cardData, x, y, z, faceDown = false) {
            const group = new THREE.Group();

            // Card base
            const cardGeometry = new THREE.BoxGeometry(0.6, 0.01, 0.9);
            const cardMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3
            });
            const card = new THREE.Mesh(cardGeometry, cardMaterial);
            card.castShadow = true;
            group.add(card);

            if (!faceDown) {
                // Card face
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 384;
               
                context.fillStyle = '#ffffff';
                context.fillRect(0, 0, 256, 384);
               
                const isRed = cardData.suit === '♥' || cardData.suit === '♦';
                context.fillStyle = isRed ? '#ff0000' : '#000000';
                context.font = 'bold 60px Georgia';
                context.fillText(cardData.value, 20, 70);
                context.font = 'bold 80px Georgia';
                context.fillText(cardData.suit, 20, 160);
               
                context.font = 'bold 60px Georgia';
                context.save();
                context.translate(256, 384);
                context.rotate(Math.PI);
                context.fillText(cardData.value, 20, 70);
                context.font = 'bold 80px Georgia';
                context.fillText(cardData.suit, 20, 160);
                context.restore();
               
                const texture = new THREE.CanvasTexture(canvas);
                const faceMaterial = new THREE.MeshBasicMaterial({ map: texture });
                const faceGeometry = new THREE.PlaneGeometry(0.59, 0.89);
                const face = new THREE.Mesh(faceGeometry, faceMaterial);
                face.rotation.x = -Math.PI / 2;
                face.position.y = 0.006;
                group.add(face);
            } else {
                // Card back
                const backCanvas = document.createElement('canvas');
                const backContext = backCanvas.getContext('2d');
                backCanvas.width = 256;
                backCanvas.height = 384;
               
                backContext.fillStyle = '#0d47a1';
                backContext.fillRect(0, 0, 256, 384);
               
                backContext.strokeStyle = '#ffffff';
                backContext.lineWidth = 4;
                backContext.strokeRect(10, 10, 236, 364);
               
                backContext.fillStyle = '#1976d2';
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 7; j++) {
                        backContext.beginPath();
                        backContext.arc(30 + i * 50, 30 + j * 50, 15, 0, Math.PI * 2);
                        backContext.fill();
                    }
                }
               
                const backTexture = new THREE.CanvasTexture(backCanvas);
                const backMaterial = new THREE.MeshBasicMaterial({ map: backTexture });
                const backGeometry = new THREE.PlaneGeometry(0.59, 0.89);
                const back = new THREE.Mesh(backGeometry, backMaterial);
                back.rotation.x = -Math.PI / 2;
                back.position.y = 0.006;
                group.add(back);
            }

            group.position.set(x, y, z);
            group.userData = { cardData, faceDown };
            scene.add(group);
            cards.push(group);
           
            return group;
        }

        function createChip(amount) {
            let color;
            switch(amount) {
                case 5: color = 0xff4444; break;
                case 25: color = 0x44ff44; break;
                case 100: color = 0x4444ff; break;
                case 500: color = 0xff44ff; break;
            }
            const material = new THREE.MeshStandardMaterial({ color });
            const chip = new THREE.Mesh(chipGeometry, material);
            chip.position.set(0, 0.92 + betChips.length * 0.06, 2);
            chip.castShadow = true;
            scene.add(chip);
            betChips.push(chip);
        }

        function animateCard(card, startX, startY, startZ, endX, endY, endZ, duration = 500) {
            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                const currentZ = startZ + (endZ - startZ) * progress;
                card.position.set(currentX, currentY, currentZ);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
        }

        function animateChip(chip, startX, startY, startZ, endX, endY, endZ, duration = 500) {
            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                const currentZ = startZ + (endZ - startZ) * progress;
                chip.position.set(currentX, currentY, currentZ);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
        }

        // Load leaderboard from server
        async function loadLeaderboard() {
            try {
                const response = await fetch('https://api.jsonbin.io/v3/b/YOUR_BIN_ID/latest');
                const data = await response.json();
                leaderboard = data.record || [];
            } catch (e) {
                // Fallback to localStorage
                leaderboard = JSON.parse(localStorage.getItem('blackjackLeaderboard')) || [];
            }
            displayLeaderboard();
        }

        function updateLeaderboard(name, score) {
            const existing = leaderboard.find(e => e.name === name);
            if (!existing) {
                leaderboard.push({ name, score });
            }
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 5);
            
            // Save to server
            (async () => {
                try {
                    await fetch('https://api.jsonbin.io/v3/b/YOUR_BIN_ID', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Master-Key': 'YOUR_API_KEY'
                        },
                        body: JSON.stringify(leaderboard)
                    });
                } catch (e) {
                    // Fallback to localStorage
                    localStorage.setItem('blackjackLeaderboard', JSON.stringify(leaderboard));
                }
            })();
            
            displayLeaderboard();
        }

        function displayLeaderboard() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            leaderboard.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: $${entry.score}`;
                list.appendChild(li);
            });
        }

        function toggleLeaderboard() {
            const ui = document.getElementById('leaderboardUI');
            ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
            if (ui.style.display === 'block') {
                document.getElementById('gameOverName').style.display = 'none';
                document.getElementById('restartBtn').style.display = 'none';
            }
        }

        function submitScore() {
            const name = document.getElementById('gameOverName').value || 'Anonymous';
            updateLeaderboard(name, maxChips);
            location.reload();
        }

        function getCardValue(card) {
            if (card.value === 'A') return 11;
            if (['K', 'Q', 'J'].includes(card.value)) return 10;
            return parseInt(card.value);
        }

        function calculateHandValue(hand) {
            let value = 0;
            let aces = 0;
           
            for (let card of hand) {
                const cardValue = getCardValue(card);
                value += cardValue;
                if (card.value === 'A') aces++;
            }
           
            while (value > 21 && aces > 0) {
                value -= 10;
                aces--;
            }
           
            return value;
        }

        function placeBet(amount) {
            if (gameState !== 'betting') return;
            if (playerChips < amount) {
                showMessage('Not enough chips!', 'lose');
                return;
            }
           
            currentBet += amount;
            playerChips -= amount;
            updateUI();
           
            document.getElementById('currentBet').style.display = 'block';
            createChip(amount);
        }

        function dealCards() {
            if (currentBet === 0) {
                showMessage('Place a bet first!', 'lose');
                return;
            }
           
            if (deck.length < 20) {
                initializeDeck();
            }
           
            gameState = 'playing';
            playerHand = [];
            dealerHand = [];
           
            // Move bet chips out of the way
            for (let i = 0; i < betChips.length; i++) {
                const chip = betChips[i];
                const newY = 0.92 + i * 0.06;
                animateChip(chip, chip.position.x, chip.position.y, chip.position.z, 3, newY, 2);
            }
           
            // Clear old cards
            for (let card of cards) {
                scene.remove(card);
            }
            cards = [];
           
            // Deal cards with animation delay
            setTimeout(() => {
                // Player first card
                const card1 = deck.pop();
                playerHand.push(card1);
                const cardMesh1 = createCard(card1, 0, 1, -3);
                animateCard(cardMesh1, 0, 1, -3, playerCardStart.x, playerCardStart.y, playerCardStart.z);
            }, 200);
           
            setTimeout(() => {
                // Dealer first card (face up)
                const card2 = deck.pop();
                dealerHand.push(card2);
                const cardMesh2 = createCard(card2, 0, 1, -3);
                animateCard(cardMesh2, 0, 1, -3, dealerCardStart.x, dealerCardStart.y, dealerCardStart.z);
            }, 400);
           
            setTimeout(() => {
                // Player second card
                const card3 = deck.pop();
                playerHand.push(card3);
                const cardMesh3 = createCard(card3, 0, 1, -3);
                animateCard(cardMesh3, 0, 1, -3, playerCardStart.x + cardSpacing, playerCardStart.y, playerCardStart.z);
            }, 600);
           
            setTimeout(() => {
                // Dealer second card (face down)
                const card4 = deck.pop();
                dealerHand.push(card4);
                dealerHiddenCard = createCard(card4, 0, 1, -3, true);
                animateCard(dealerHiddenCard, 0, 1, -3, dealerCardStart.x + cardSpacing, dealerCardStart.y, dealerCardStart.z);
               
                updateUI();
                showActionButtons();
                checkBlackjack();
            }, 800);
        }

        function hit() {
            const current = currentHand === 'first' ? playerHand : secondHand;
            const newCard = deck.pop();
            current.push(newCard);
           
            const offset = currentHand === 'second' ? 2 : 0;
            const cardX = playerCardStart.x + (current.length - 1) * cardSpacing + offset;
            const cardMesh = createCard(newCard, 0, 1, -3);
            animateCard(cardMesh, 0, 1, -3, cardX, playerCardStart.y, playerCardStart.z);
           
            canDouble = false;
            updateUI();
           
            const currentValue = calculateHandValue(current);
            if (currentValue > 21) {
                if (secondHand && currentHand === 'first') {
                    // Bust first hand, switch to second
                    currentHand = 'second';
                    showActionButtons();
                } else {
                    endGame('bust');
                }
            } else {
                document.getElementById('doubleBtn').style.display = 'none';
            }
        }

        function stand() {
            if (secondHand && currentHand === 'first') {
                currentHand = 'second';
                showActionButtons();
                updateUI();
            } else {
                gameState = 'dealer';
                hideActionButtons();
               
                // Reveal dealer's hidden card
                if (dealerHiddenCard) {
                    scene.remove(dealerHiddenCard);
                    const cardData = dealerHiddenCard.userData.cardData;
                    createCard(cardData, dealerCardStart.x + cardSpacing, dealerCardStart.y, dealerCardStart.z);
                }
               
                updateUI();
               
                // Dealer draws
                setTimeout(() => dealerPlay(), 1000);
            }
        }

        function doubleDown() {
            if (playerChips < currentBet) {
                showMessage('Not enough chips to double!', 'lose');
                return;
            }
           
            playerChips -= currentBet;
            currentBet *= 2;
            updateUI();
           
            // Hit once
            const newCard = deck.pop();
            playerHand.push(newCard);
            const cardX = playerCardStart.x + (playerHand.length - 1) * cardSpacing;
            const cardMesh = createCard(newCard, 0, 1, -3);
            animateCard(cardMesh, 0, 1, -3, cardX, playerCardStart.y, playerCardStart.z);
           
            updateUI();
           
            const playerValue = calculateHandValue(playerHand);
            if (playerValue > 21) {
                setTimeout(() => endGame('bust'), 500);
            } else {
                setTimeout(() => stand(), 500);
            }
        }

        function split() {
            if (playerChips < currentBet) {
                showMessage('Not enough chips to split!', 'lose');
                return;
            }
           
            playerChips -= currentBet;
            const poppedCard = playerHand.pop();
            secondHand = [poppedCard];
           
            // Find and animate the popped card to second hand position
            let poppedMesh = null;
            for (let card of cards) {
                if (card.userData.cardData === poppedCard) {
                    poppedMesh = card;
                    break;
                }
            }
            if (poppedMesh) {
                animateCard(poppedMesh, poppedMesh.position.x, poppedMesh.position.y, poppedMesh.position.z, playerCardStart.x + 2, playerCardStart.y, playerCardStart.z);
            }
           
            // Deal to first hand
            const newCard1 = deck.pop();
            playerHand.push(newCard1);
            const cardX1 = playerCardStart.x + (playerHand.length - 1) * cardSpacing;
            const cardMesh1 = createCard(newCard1, 0, 1, -3);
            animateCard(cardMesh1, 0, 1, -3, cardX1, playerCardStart.y, playerCardStart.z);
           
            // Deal to second hand
            const newCard2 = deck.pop();
            secondHand.push(newCard2);
            const cardX2 = playerCardStart.x + (secondHand.length - 1) * cardSpacing + 2; // offset for second hand
            const cardMesh2 = createCard(newCard2, 0, 1, -3);
            animateCard(cardMesh2, 0, 1, -3, cardX2, playerCardStart.y, playerCardStart.z);
           
            updateUI();
            document.getElementById('splitBtn').style.display = 'none';
            canDouble = false;
        }

        function dealerPlay() {
            let dealerValue = calculateHandValue(dealerHand);
           
            if (dealerValue < 17) {
                setTimeout(() => {
                    const newCard = deck.pop();
                    dealerHand.push(newCard);
                    const cardX = dealerCardStart.x + (dealerHand.length - 1) * cardSpacing;
                    const cardMesh = createCard(newCard, 0, 1, -3);
                    animateCard(cardMesh, 0, 1, -3, cardX, dealerCardStart.y, dealerCardStart.z);
                    updateUI();
                    dealerPlay();
                }, 1000);
            } else {
                setTimeout(() => determineWinner(), 500);
            }
        }

        function checkBlackjack() {
            const playerValue = calculateHandValue(playerHand);
           
            if (playerValue === 21) {
                // Check if dealer also has blackjack
                const dealerValue = calculateHandValue(dealerHand);
                if (dealerValue === 21) {
                    endGame('push');
                } else {
                    endGame('blackjack');
                }
            } else {
                canDouble = playerHand.length === 2;
                if (canDouble) {
                    document.getElementById('doubleBtn').style.display = 'block';
                }
                if (canDouble && playerHand[0].value === playerHand[1].value && !secondHand) {
                    document.getElementById('splitBtn').style.display = 'block';
                }
            }
        }

        function determineWinner() {
            const dealerValue = calculateHandValue(dealerHand);
            const hands = secondHand ? [playerHand, secondHand] : [playerHand];
            let results = [];
           
            for (let hand of hands) {
                const handValue = calculateHandValue(hand);
                if (dealerValue > 21) {
                    results.push('win');
                } else if (handValue > dealerValue) {
                    results.push('win');
                } else if (dealerValue > handValue) {
                    results.push('lose');
                } else {
                    results.push('push');
                }
            }
           
            // Apply payouts
            for (let result of results) {
                switch (result) {
                    case 'win':
                        playerChips += currentBet * 2;
                        break;
                    case 'push':
                        playerChips += currentBet;
                        break;
                    // lose: no change
                }
            }
           
            // Determine overall message
            const wins = results.filter(r => r === 'win').length;
            const pushes = results.filter(r => r === 'push').length;
            const losses = results.filter(r => r === 'lose').length;
           
            let message, messageClass;
            if (wins === results.length) {
                message = secondHand ? 'You win both hands!' : 'YOU WIN!';
                messageClass = 'win';
            } else if (losses === results.length) {
                message = secondHand ? 'Dealer wins both hands!' : 'DEALER WINS!';
                messageClass = 'lose';
            } else {
                message = 'Mixed results!';
                messageClass = 'push';
            }
           
            showMessage(message, messageClass);
            setTimeout(() => finishGame(), 2500);
        }

        function finishGame() {
            currentBet = 0;
            gameState = 'betting';
           
            // Remove bet chips
            for (let chip of betChips) {
                scene.remove(chip);
            }
            betChips = [];
           
            // Clear cards
            for (let card of cards) {
                scene.remove(card);
            }
            cards = [];
           
            secondHand = null;
            currentHand = 'first';
           
            maxChips = Math.max(maxChips, playerChips);
           
            setTimeout(() => {
                updateUI();
                document.getElementById('dealBtn').style.display = 'block';
                document.getElementById('currentBet').style.display = 'none';
               
                if (playerChips <= 0) {
                    showMessage('Game Over!', 'lose');
                    setTimeout(() => {
                        document.getElementById('leaderboardUI').style.display = 'block';
                        document.getElementById('leaderboardUI').style.position = 'fixed';
                        document.getElementById('leaderboardUI').style.top = '50%';
                        document.getElementById('leaderboardUI').style.left = '50%';
                        document.getElementById('leaderboardUI').style.transform = 'translate(-50%, -50%)';
                        document.getElementById('restartBtn').style.display = 'block';
                        document.getElementById('gameOverName').style.display = 'block';
                        document.getElementById('restartBtn').textContent = 'Submit Score and Play Again';
                        // Hide other UI
                        document.getElementById('chipDisplay').style.display = 'none';
                        document.getElementById('nameInput').style.display = 'none';
                        document.getElementById('bettingUI').style.display = 'none';
                        document.getElementById('actionButtons').style.display = 'none';
                        document.getElementById('currentBet').style.display = 'none';
                        document.getElementById('playerValue').style.display = 'none';
                        document.getElementById('playerValue2').style.display = 'none';
                        document.getElementById('dealerValue').style.display = 'none';
                    }, 2500);
                }
            }, 3000);
        }

        function endGame(result) {
            gameState = 'ended';
            hideActionButtons();
           
            let message = '';
            let messageClass = '';
           
            switch(result) {
                case 'blackjack':
                    playerChips += currentBet * 2.5;
                    message = 'BLACKJACK! You win!';
                    messageClass = 'win';
                    break;
                case 'win':
                    playerChips += currentBet * 2;
                    message = 'YOU WIN!';
                    messageClass = 'win';
                    break;
                case 'lose':
                    message = 'DEALER WINS!';
                    messageClass = 'lose';
                    break;
                case 'bust':
                    message = 'BUST! You lose!';
                    messageClass = 'lose';
                    break;
                case 'push':
                    playerChips += currentBet;
                    message = 'PUSH!';
                    messageClass = 'push';
                    break;
            }
           
            showMessage(message, messageClass);
            setTimeout(() => finishGame(), 2500);
        }

        function showActionButtons() {
            document.getElementById('dealBtn').style.display = 'none';
            document.getElementById('hitBtn').style.display = 'block';
            document.getElementById('standBtn').style.display = 'block';
        }

        function hideActionButtons() {
            document.getElementById('hitBtn').style.display = 'none';
            document.getElementById('standBtn').style.display = 'none';
            document.getElementById('doubleBtn').style.display = 'none';
            document.getElementById('splitBtn').style.display = 'none';
        }

        function updateUI() {
            document.getElementById('chipAmount').textContent = playerChips;
            document.getElementById('betAmount').textContent = currentBet;
           
            if (playerHand.length > 0) {
                const playerValue = calculateHandValue(playerHand);
                document.getElementById('playerValueText').textContent = playerValue;
                document.getElementById('playerValue').style.display = 'block';
                if (secondHand) {
                    document.getElementById('playerValue').style.left = '30%';
                } else {
                    document.getElementById('playerValue').style.left = '50%';
                }
            } else {
                document.getElementById('playerValue').style.display = 'none';
            }
           
            if (secondHand) {
                const playerValue2 = calculateHandValue(secondHand);
                document.getElementById('playerValueText2').textContent = playerValue2;
                document.getElementById('playerValue2').style.display = 'block';
                document.getElementById('playerValue2').style.left = '70%';
                document.getElementById('playerValue2').style.bottom = '180px';
                document.getElementById('playerValue2').style.transform = 'translateX(-50%)';
            } else {
                document.getElementById('playerValue2').style.display = 'none';
            }
           
            if (dealerHand.length > 0 && gameState !== 'playing') {
                const dealerValue = calculateHandValue(dealerHand);
                document.getElementById('dealerValueText').textContent = dealerValue;
                document.getElementById('dealerValue').style.display = 'block';
            } else if (dealerHand.length > 0 && gameState === 'playing') {
                // Show only first card value during play
                const firstCardValue = getCardValue(dealerHand[0]);
                document.getElementById('dealerValueText').textContent = firstCardValue;
                document.getElementById('dealerValue').style.display = 'block';
            } else {
                document.getElementById('dealerValue').style.display = 'none';
            }
        }

        function showMessage(message, type) {
            const messageEl = document.getElementById('messageDisplay');
            messageEl.textContent = message;
            messageEl.className = 'show ' + type + '-message';
           
            setTimeout(() => {
                messageEl.classList.remove('show');
            }, 2500);
        }

        function simulateLoading() {
            let progress = 0;
            const loadingBar = document.getElementById('loadingBar');
            const loadingScreen = document.getElementById('loadingScreen');
           
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    progress = 100;
                    loadingBar.style.width = '100%';
                    setTimeout(() => {
                        loadingScreen.classList.add('hidden');
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                        }, 500);
                    }, 300);
                    clearInterval(interval);
                } else {
                    loadingBar.style.width = progress + '%';
                }
            }, 100);
        }

        function animate() {
            requestAnimationFrame(animate);
           
            // Subtle camera movement
            const time = Date.now() * 0.0001;
            camera.position.x = Math.sin(time) * 0.3;
           
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize game
        init();
    </script>
</body>
</html>