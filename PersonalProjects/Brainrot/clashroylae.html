<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale MVP</title>
    <style>
        /* River and bridges */
        #river {
            position: absolute;
            left: 0;
            top: 245px;
            width: 100%;
            height: 30px;
            background: linear-gradient(to bottom, #4fc3f7 60%, #1976d2 100%);
            z-index: 2;
        }
        .bridge {
            position: absolute;
            width: 60px;
            height: 30px;
            top: 245px;
            background: #bfa76f;
            border-radius: 8px;
            z-index: 3;
            border: 2px solid #8d6e3f;
        }
        #bridge-left {
            left: 70px;
        }
        #bridge-right {
            right: 70px;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            width: 400px;
            height: 700px;
            background: #2a2a2a;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
        }

        #battlefield {
            width: 100%;
            height: 500px;
            background: linear-gradient(to bottom, #4a7c59, #3a5f47);
            position: relative;
            border-bottom: 3px solid #333;
        }

        .lane {
            position: absolute;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.1);
        }

        .lane.left { left: 33%; }
        .lane.right { right: 33%; }

        .tower {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .tower.player {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 3px solid #4a5fe8;
        }

        .tower.enemy {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border: 3px solid #f5576c;
        }

        .tower.king {
            width: 60px;
            height: 60px;
            font-size: 14px;
        }

        .tower.destroyed {
            background: #555;
            opacity: 0.5;
            border-color: #333;
        }

        .tower-health {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        #playerKing { bottom: 30px; left: 50%; transform: translateX(-50%); }
        #playerLeft { bottom: 100px; left: 20%; }
        #playerRight { bottom: 100px; right: 20%; }
        #enemyKing { top: 30px; left: 50%; transform: translateX(-50%); }
        #enemyLeft { top: 100px; left: 20%; }
        #enemyRight { top: 100px; right: 20%; }

        #ui {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(to bottom, #333, #222);
            padding: 10px;
        }

        #elixirBar {
            width: 90%;
            height: 20px;
            background: #444;
            border-radius: 10px;
            margin: 0 auto 10px;
            overflow: hidden;
            position: relative;
            border: 2px solid #555;
        }

        #elixirFill {
            height: 100%;
            background: linear-gradient(90deg, #e942f5, #8e42f5);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(233, 66, 245, 0.5);
        }

        #elixirText {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 20px;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        #cards {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            gap: 5px;
        }

        .card {
            width: 70px;
            height: 90px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 3px solid #4a5fe8;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .card:hover:not(.disabled) {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }

        .card.selected {
            border-color: #ffd700;
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .card-name {
            font-size: 10px;
            color: white;
            font-weight: bold;
            text-align: center;
        }

        .card-cost {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #8e42f5;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            border: 2px solid #fff;
        }

        .unit {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.1s linear;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .unit.player {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 2px solid #4a5fe8;
        }

        .unit.enemy {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border: 2px solid #f5576c;
        }

        .unit-health {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #0f0;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 8px;
        }

        .projectile {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ffeb3b;
            border-radius: 50%;
            z-index: 15;
            box-shadow: 0 0 10px rgba(255,235,59,0.8);
        }

        #timer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            z-index: 20;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
        }

        #gameOver h2 {
            margin-bottom: 15px;
            font-size: 28px;
        }

        #gameOver button {
            padding: 10px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #gameOver button:hover {
            transform: scale(1.05);
        }

        .damage-text {
            position: absolute;
            color: #ff0;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            z-index: 50;
            animation: damageFloat 1s ease-out forwards;
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="battlefield">
            <div id="river"></div>
            <div class="bridge" id="bridge-left"></div>
            <div class="bridge" id="bridge-right"></div>
            <div class="lane left"></div>
            <div class="lane right"></div>
            
            <div id="timer">3:00</div>
            
            <!-- Enemy Towers -->
            <div class="tower enemy king" id="enemyKing">
                üëë
                <span class="tower-health">2500</span>
            </div>
            <div class="tower enemy" id="enemyLeft">
                üè∞
                <span class="tower-health">1500</span>
            </div>
            <div class="tower enemy" id="enemyRight">
                üè∞
                <span class="tower-health">1500</span>
            </div>
            
            <!-- Player Towers -->
            <div class="tower player king" id="playerKing">
                üëë
                <span class="tower-health">2500</span>
            </div>
            <div class="tower player" id="playerLeft">
                üè∞
                <span class="tower-health">1500</span>
            </div>
            <div class="tower player" id="playerRight">
                üè∞
                <span class="tower-health">1500</span>
            </div>
        </div>
        
        <div id="ui">
            <div id="elixirBar">
                <div id="elixirFill"></div>
                <div id="elixirText">0 / 10</div>
            </div>
            
            <div id="cards">
                <div class="card" data-type="knight" data-cost="3">
                    <span class="card-icon">‚öîÔ∏è</span>
                    <span class="card-name">Knight</span>
                    <span class="card-cost">3</span>
                </div>
                <div class="card" data-type="archer" data-cost="2">
                    <span class="card-icon">üèπ</span>
                    <span class="card-name">Archer</span>
                    <span class="card-cost">2</span>
                </div>
                <div class="card" data-type="wizard" data-cost="5">
                    <span class="card-icon">üßô</span>
                    <span class="card-name">Wizard</span>
                    <span class="card-cost">5</span>
                </div>
                <div class="card" data-type="minion" data-cost="3">
                    <span class="card-icon">ü¶ã</span>
                    <span class="card-name">Minion</span>
                    <span class="card-cost">3</span>
                </div>
                <div class="card" data-type="giant" data-cost="7">
                    <span class="card-icon">üëπ</span>
                    <span class="card-name">Giant</span>
                    <span class="card-cost">7</span>
                </div>
                <div class="card" data-type="fireball" data-cost="4">
                    <span class="card-icon">üî•</span>
                    <span class="card-name">Fireball</span>
                    <span class="card-cost">4</span>
                </div>
            </div>
        </div>
        
        <div id="gameOver">
            <h2 id="gameResult"></h2>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        // Game state
        const game = {
            elixir: 5,
            maxElixir: 10,
            elixirRate: 1,
            selectedCard: null,
            units: [],
            projectiles: [],
            gameTime: 180, // 3 minutes
            gameRunning: true,
            towers: {
                player: {
                    king: { health: 2500, maxHealth: 2500, x: 200, y: 470 },
                    left: { health: 1500, maxHealth: 1500, x: 80, y: 400 },
                    right: { health: 1500, maxHealth: 1500, x: 320, y: 400 }
                },
                enemy: {
                    king: { health: 2500, maxHealth: 2500, x: 200, y: 30 },
                    left: { health: 1500, maxHealth: 1500, x: 80, y: 100 },
                    right: { health: 1500, maxHealth: 1500, x: 320, y: 100 }
                }
            }
        };

        // Card definitions
        const cardTypes = {
            knight: {
                health: 300,
                damage: 50,
                speed: 1,
                range: 40,
                attackSpeed: 1000,
                icon: '‚öîÔ∏è',
                flying: false
            },
            archer: {
                health: 150,
                damage: 30,
                speed: 1.5,
                range: 120,
                attackSpeed: 800,
                icon: 'üèπ',
                flying: false
            },
            wizard: {
                health: 200,
                damage: 80,
                speed: 1,
                range: 100,
                attackSpeed: 1500,
                icon: 'üßô',
                flying: false
            },
            giant: {
                health: 800,
                damage: 100,
                speed: 0.5,
                range: 40,
                attackSpeed: 2000,
                icon: 'üëπ',
                flying: false
            },
            minion: {
                health: 90,
                damage: 40,
                speed: 2,
                range: 40,
                attackSpeed: 900,
                icon: 'ü¶ã',
                flying: true
            },
            fireball: {
                damage: 200,
                radius: 80,
                icon: 'üî•'
            }
        };

        // Tower attack stats
        const towerStats = {
            normal: {
                damage: 60,
                range: 120,
                attackSpeed: 1200
            },
            king: {
                damage: 120,
                range: 140,
                attackSpeed: 1100
            }
        };

        // Unit class
        class Unit {
            constructor(type, x, y, team) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.team = team;
                this.stats = {...cardTypes[type]};
                this.health = this.stats.health;
                this.target = null;
                this.lastAttack = 0;
                this.element = this.createElement();
            }

            createElement() {
                const el = document.createElement('div');
                el.className = `unit ${this.team}`;
                el.innerHTML = `${this.stats.icon}<span class="unit-health">${this.health}</span>`;
                el.style.left = this.x - 15 + 'px';
                el.style.top = this.y - 15 + 'px';
                document.getElementById('battlefield').appendChild(el);
                return el;
            }

            update() {
                // Only find a new target if there is no target or the current target is dead/destroyed
                if (!this.target || this.target.health <= 0) {
                    this.findTarget();
                }

                if (this.target) {
                    const dist = this.getDistance(this.target);
                    const isFlying = this.stats.flying === true;
                    // River y: 245 to 275, bridges at x: 70-130 and 270-330
                    let canCrossRiver = false;
                    if (isFlying) {
                        canCrossRiver = true;
                    } else {
                        // Check if unit is on a bridge when crossing river
                        // If moving from one side of river to the other, must be on bridge
                        const nextX = this.x + Math.cos(Math.atan2(this.target.y - this.y, this.target.x - this.x)) * this.stats.speed;
                        const nextY = this.y + Math.sin(Math.atan2(this.target.y - this.y, this.target.x - this.x)) * this.stats.speed;
                        // If crossing river
                        if ((this.y < 245 && nextY >= 245) || (this.y > 275 && nextY <= 275)) {
                            // Check if x is within bridge bounds
                            if ((this.x >= 70 && this.x <= 130) || (this.x >= 270 && this.x <= 330)) {
                                canCrossRiver = true;
                            }
                        } else {
                            canCrossRiver = true;
                        }
                    }

                    if (dist <= this.stats.range) {
                        // Attack
                        const now = Date.now();
                        if (now - this.lastAttack > this.stats.attackSpeed) {
                            this.attack();
                            this.lastAttack = now;
                        }
                    } else if (canCrossRiver) {
                        // Move towards target
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        this.x += Math.cos(angle) * this.stats.speed;
                        this.y += Math.sin(angle) * this.stats.speed;
                    }
                    // else: blocked by river, do not move
                }

                this.element.style.left = this.x - 15 + 'px';
                this.element.style.top = this.y - 15 + 'px';
                this.element.querySelector('.unit-health').textContent = Math.ceil(this.health);
            }

            findTarget() {
                // Find the closest valid target (towers or enemy units)
                const enemyTeam = this.team === 'player' ? 'enemy' : 'player';
                const towers = game.towers[enemyTeam];
                let minDist = Infinity;
                let closest = null;

                if (this.type === 'giant') {
                    // Giant only targets buildings (towers)
                    for (let key in towers) {
                        if (towers[key].health > 0) {
                            const dist = this.getDistance(towers[key]);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = towers[key];
                            }
                        }
                    }
                } else {
                    // Other units: towers first, then enemy units
                    for (let key in towers) {
                        if (towers[key].health > 0) {
                            const dist = this.getDistance(towers[key]);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = towers[key];
                            }
                        }
                    }
                    game.units.forEach(unit => {
                        if (unit.team !== this.team && unit.health > 0) {
                            // Only ranged units can target flying units
                            if (unit.stats.flying && this.stats.range <= 50) return;
                            const dist = this.getDistance(unit);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = unit;
                            }
                        }
                    });
                }
                this.target = closest;
            }

            getDistance(target) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            attack() {
                if (this.stats.range > 50) {
                    // Ranged attack - create projectile
                    game.projectiles.push(new Projectile(this.x, this.y, this.target, this.stats.damage));
                } else {
                    // Melee attack
                    this.dealDamage(this.target, this.stats.damage);
                }
            }

            dealDamage(target, damage) {
                target.health -= damage;
                showDamage(target.x, target.y, damage);
                
                if (target.health <= 0) {
                    if (target.element) {
                        // It's a unit
                        target.element.remove();
                        const index = game.units.indexOf(target);
                        if (index > -1) game.units.splice(index, 1);
                    } else {
                        // It's a tower
                        updateTowerDisplay();
                    }
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                showDamage(this.x, this.y, damage);
                if (this.health <= 0) {
                    this.element.remove();
                    const index = game.units.indexOf(this);
                    if (index > -1) game.units.splice(index, 1);
                }
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, target, damage) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.speed = 5;
                this.element = this.createElement();
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'projectile';
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                document.getElementById('battlefield').appendChild(el);
                return el;
            }

            update() {
                if (!this.target || this.target.health <= 0) {
                    this.remove();
                    return false;
                }

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 10) {
                    // Hit target
                    if (this.target.takeDamage) {
                        this.target.takeDamage(this.damage);
                    } else {
                        this.target.health -= this.damage;
                        showDamage(this.target.x, this.target.y, this.damage);
                        updateTowerDisplay();
                    }
                    this.remove();
                    return false;
                }

                // Move towards target
                const angle = Math.atan2(dy, dx);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                return true;
            }

            remove() {
                this.element.remove();
            }
        }

        // Tower class
        class Tower {
            constructor(team, key, data) {
                this.team = team;
                this.key = key;
                this.x = data.x;
                this.y = data.y;
                this.health = data.health;
                this.maxHealth = data.maxHealth;
                this.isKing = key === 'king';
                this.attackEnabled = !this.isKing; // King tower starts disabled
                this.lastAttack = 0;
                this.target = null;
            }

            update() {
                // Enable king tower if any side tower destroyed
                if (this.isKing && !this.attackEnabled) {
                    const towers = game.towers[this.team];
                    if (towers.left.health <= 0 || towers.right.health <= 0) {
                        this.attackEnabled = true;
                    }
                }
                if (!this.attackEnabled || this.health <= 0) return;

                // Find target if needed
                if (!this.target || this.target.health <= 0 || this.getDistance(this.target) > this.getStats().range) {
                    this.target = this.findTarget();
                }
                if (this.target && this.target.health > 0) {
                    const now = Date.now();
                    if (now - this.lastAttack > this.getStats().attackSpeed) {
                        this.attack();
                        this.lastAttack = now;
                    }
                }
            }

            findTarget() {
                // Attack closest enemy unit in range
                let minDist = Infinity, closest = null;
                game.units.forEach(unit => {
                    if (unit.team !== this.team && unit.health > 0) {
                        // Only target ground units if not king or if king, can target both
                        if (!this.isKing && unit.stats.flying) return;
                        const dist = this.getDistance(unit);
                        if (dist < this.getStats().range && dist < minDist) {
                            minDist = dist;
                            closest = unit;
                        }
                    }
                });
                return closest;
            }

            getDistance(target) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            getStats() {
                return this.isKing ? towerStats.king : towerStats.normal;
            }

            attack() {
                // Ranged attack (projectile)
                game.projectiles.push(new Projectile(this.x, this.y, this.target, this.getStats().damage));
            }
        }

        // Initialize towers as Tower instances
        function initTowers() {
            for (const team of ['player', 'enemy']) {
                for (const key of ['king', 'left', 'right']) {
                    const t = game.towers[team][key];
                    game.towers[team][key] = new Tower(team, key, t);
                }
            }
        }

        // Show damage numbers
        function showDamage(x, y, damage) {
            const el = document.createElement('div');
            el.className = 'damage-text';
            el.textContent = '-' + damage;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.getElementById('battlefield').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // Card selection
        document.querySelectorAll('.card').forEach(card => {
            card.addEventListener('click', function() {
                const cost = parseInt(this.dataset.cost);
                if (game.elixir >= cost) {
                    document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                    this.classList.add('selected');
                    game.selectedCard = {
                        type: this.dataset.type,
                        cost: cost
                    };
                }
            });
        });

        // Battlefield click for unit placement
        document.getElementById('battlefield').addEventListener('click', function(e) {
            if (!game.selectedCard || !game.gameRunning) return;
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            // Only allow placement in bottom half for player
            if (y > 250) {
                if (game.selectedCard.type === 'fireball') {
                    // Fireball spell - instant damage in area
                    const spell = cardTypes.fireball;
                    // Damage all enemies in radius
                    game.units.forEach(unit => {
                        if (unit.team === 'enemy') {
                            const dist = Math.sqrt((unit.x - x) ** 2 + (unit.y - y) ** 2);
                            if (dist < spell.radius) {
                                unit.takeDamage(spell.damage);
                            }
                        }
                    });
                    // Check towers
                    for (let key in game.towers.enemy) {
                        const tower = game.towers.enemy[key];
                        const dist = Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2);
                        if (dist < spell.radius && tower.health > 0) {
                            tower.health -= spell.damage;
                            showDamage(tower.x, tower.y, spell.damage);
                            updateTowerDisplay();
                        }
                    }
                    // Visual effect
                    const explosion = document.createElement('div');
                    explosion.style.position = 'absolute';
                    explosion.style.left = x - 40 + 'px';
                    explosion.style.top = y - 40 + 'px';
                    explosion.style.width = '80px';
                    explosion.style.height = '80px';
                    explosion.style.borderRadius = '50%';
                    explosion.style.background = 'radial-gradient(circle, rgba(255,100,0,0.8), transparent)';
                    explosion.style.animation = 'damageFloat 0.5s ease-out forwards';
                    this.appendChild(explosion);
                    setTimeout(() => explosion.remove(), 500);
                } else if (game.selectedCard.type === 'minion') {
                    // Spawn 3 minions in a small spread
                    for (let i = 0; i < 3; i++) {
                        const angle = (-10 + i * 10) * Math.PI / 180;
                        const mx = x + Math.cos(angle) * 15;
                        const my = y + Math.sin(angle) * 15;
                        game.units.push(new Unit('minion', mx, my, 'player'));
                    }
                } else {
                    // Spawn unit
                    game.units.push(new Unit(game.selectedCard.type, x, y, 'player'));
                }
                game.elixir -= game.selectedCard.cost;
                updateElixir();
            }
            if (!game.gameRunning) return;
            
            if (game.towers.player.king.health <= 0) {
                endGame('You Lose!');
            } else if (game.towers.enemy.king.health <= 0) {
                endGame('You Win!');
            }
        });

        function endGame(result) {
            game.gameRunning = false;
            document.getElementById('gameResult').textContent = result;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Reset game
        function resetGame() {
            location.reload();
        }

        // Update timer
        function updateTimer() {
            if (!game.gameRunning) return;
            
            game.gameTime--;
            const minutes = Math.floor(game.gameTime / 60);
            const seconds = game.gameTime % 60;
            document.getElementById('timer').textContent = 
                minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
            
            if (game.gameTime <= 0) {
                // Time's up - determine winner by tower health
                const playerHealth = game.towers.player.king.health + 
                                    game.towers.player.left.health + 
                                    game.towers.player.right.health;
                const enemyHealth = game.towers.enemy.king.health + 
                                   game.towers.enemy.left.health + 
                                   game.towers.enemy.right.health;
                
                if (playerHealth > enemyHealth) {
                    endGame('You Win!');
                } else if (enemyHealth > playerHealth) {
                    endGame('You Lose!');
                } else {
                    endGame('Draw!');
                }
            }
        }

        // AI opponent
        function aiPlay() {
            if (!game.gameRunning) return;
            
            // Simple AI that spawns random units
            if (Math.random() < 0.3) { // 30% chance per second
                const availableCards = ['knight', 'archer', 'wizard', 'giant'];
                const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
                const cost = parseInt(document.querySelector(`[data-type="${randomCard}"]`).dataset.cost);
                
                if (game.towers.enemy.king.health > 0) { // AI has elixir (simplified)
                    const x = 80 + Math.random() * 240;
                    const y = 50 + Math.random() * 100;
                    game.units.push(new Unit(randomCard, x, y, 'enemy'));
                }
            }
        }

        // Main game loop
        function gameLoop() {
            if (!game.gameRunning) return;

            // Regenerate elixir
            if (game.elixir < game.maxElixir) {
                game.elixir += game.elixirRate / 60; // 60 FPS
                game.elixir = Math.min(game.elixir, game.maxElixir);
                updateElixir();
            }

            // Update towers (attacks)
            for (const team of ['player', 'enemy']) {
                for (const key of ['king', 'left', 'right']) {
                    game.towers[team][key].update();
                }
            }

            // Update units
            game.units.forEach(unit => unit.update());

            // Update projectiles
            game.projectiles = game.projectiles.filter(p => p.update());

            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        updateElixir();
        updateTowerDisplay();
        initTowers();
        gameLoop();
        setInterval(updateTimer, 1000);
        setInterval(aiPlay, 1000);
    </script>
</body>
</html>
